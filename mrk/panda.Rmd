---
title: 'panda: pangenome annotations data analysis'
author: "Lorenzo Tattini"
date: "`r Sys.Date()`"
### html documents may cause problems on Hulk (knit fails)
### while pdf documents may casue problems on macOS 
### (latex fails to compile the tex file of the markdown) 
output: html_document
---

## Warning Messages

With impg 0.2.0 it is normal to get a warning message stating:

`thread 'main' panicked at src/main.rs:205:56:`

`Target name not found in index`

This is related to the behaviour of `wfmash` who, given to fasta files A and B, does not align both A vs B and B vs A but instead only aligns A vs B.

## TODO

Retrieve the sequences of each block and save them? Probably this is not a wise thing to do. With the new output format it is easy to do this on the fly.

## Input Files and Formats

The input files are: 1) an alignment (e.g. "../aln/sc-phhd-1.paf"), 2) the annotations of the contigs aligned (e.g. as in "/.../data/nano-assemblies-pansn-2024") named in pansn format but with data in classic format, 3) their unique identifiers (e.g. "../ids/ids-ps.txt")

The alignment file is in paf format. The delimiter (see https://github.com/pangenome/PanSN-spec) is "#". The annotations are in gff format. The file are named using the "-" separator. E.g. in the alignment we may have in line 1 and column 1: "SGDref#0#chrI". The corresponding annotations file is named "SGDref-0-features.gff" and it reports all the annotations for all the corresponding contigs.

## Quick Run

Before running the markdown remember to:

- check the input data folder of the annotation files (`dir_anno`)
- make a copy of the input alignment in paf format ("/.../aln/graph-name.paf")
- make the input ("/.../ids/ids-ps.txt") file with the ids (e.g. "SGDref-0", "AIF-1", "AIF-2") of the strains used to build the graph induced from the alignment
- choose if mitochondrial features should be used (in case they are attached to the first available haplotype) with `with_mito`
- choose the correct line according to the version of impg installed
- check all chunks with `eval = FALSE`

## Analysis

```{bash prepares the gff files}
## settings -------------------------------------------------------------------

### with mitochondrial sequence in one haplotype?
with_mito="FALSE"

### the gff files repository
dir_anno="${HOME}/data/nano-assemblies-pansn-2024/annotations"

## clmnt ----------------------------------------------------------------------

### folders
dir_base=$(dirname "${PWD}")
dir_out="${dir_base}/anno/gff"
if [[ -d "${dir_out}" ]]; then rm -rf "${dir_out}"; fi
mkdir -p "${dir_out}"

### the vector with the strain-haplotypes ids
declare -a gff_ids
file_ids="${dir_base}/ids/ids-ps.txt"
while IFS="\n" read -r one_line; do
    gff_ids+=("${one_line}")
done < "${file_ids}"

for strainhaplo_id in "${gff_ids[@]}"; do
  path_gff=$(find "${dir_anno}" -name "${strainhaplo_id}*gff")
  name_gff=$(basename "${path_gff}")
  strain_id=$(basename "${path_gff}" | cut -f 1 -d "-") # e.g. ADE
  mito_name="${strain_id}-mt-features.gff"
  path_mito_gff=$(find "${dir_anno}" -name "${mito_name}")
  gff_type=$(basename "${path_gff}" | cut -f 2 -d "-") # e.g. 0 or 1
  if [[ "${with_mito}" == "TRUE" && \
        -f "${path_mito_gff}" && \
        "${asse_type}" != "2" ]]; then
    cat <(grep -v "^#" "${path_gff}") <(grep -v "^#" "${path_mito_gff}") \
    > "${dir_out}/${name_gff}"
  else
    grep -v "^#" "${path_gff}" > "${dir_out}/${name_gff}"
  fi
done

```

Here we transform the annotation files in gff format to bed files (without header, otherwise impg crashes). The format of the annotations file for the reference genome are slightly different compared to the phenovar data. So we have to process them separately. Moreover, when we process the phenovar data we can filter out the genes with a systematic name since these names will be brought in by the reference annotations. This reduces the calculations needed from impg and thus results in a smaller impg output.

```{r transforms the gff files to bed files}
## header ---------------------------------------------------------------------

options(scipen = 999)
options(stringsAsFactors = F)
rm(list = ls())
library(data.table)
library(this.path)
library(scriptName)

## settings -------------------------------------------------------------------

### fixed settings
dirBase <- dirname(this.dir())
dirAnnoGff <- file.path(Sys.getenv("HOME"), "data",
                        "nano-assemblies-pansn-2024", "annotations", "nuclear")
dirOut <- file.path(dirBase, "anno", "bed")
unlink(dirOut, recursive = T)
dir.create(dirOut, recursive = T, showWarnings = F)
idRef <- "SGDref"
hdGff <- c("Chr_id", "Strain_id", "Feat_type", "S_coord",
           "E_coord", "S_val", "Strand_id", "Frame_id", "Attribute_str")
vtClassSrt <- c("gene",
                "pseudogene")
# vtClassSrt <- c("gene",
#                 "pseudogene",
#                 "intron",
#                 "five_prime_UTR_intron",
#                 "noncoding_exon",
#                 "plus_1_translational_frameshift",
#                 "blocked_reading_frame",
#                 "external_transcribed_spacer_region",
#                 "internal_transcribed_spacer_region",
#                 "ARS",
#                 "ARS_consensus_sequence",
#                 "TY1",
#                 "TY1/TY2_soloLTR",
#                 "TY1_truncated",
#                 "TY2",
#                 "TY3_soloLTR",
#                 "TY4_soloLTR",
#                 "TSU4_soloLTR",
#                 "TY4_truncated",
#                 "TY5",
#                 "TY5_soloLTR",
#                 "LTR_retrotransposon",
#                 "long_terminal_repeat",
#                 "W_region",
#                 "Z1_region",
#                 "Z2_region",
#                 "centromere",
#                 "centromere_DNA_Element_I",
#                 "centromere_DNA_Element_II",
#                 "centromere_DNA_Element_III",
#                 "matrix_attachment_site",
#                 "X_element",
#                 "X_element_partial",
#                 "X_element_combinatorial_repeat",
#                 "X_region",
#                 "Y_prime_element",
#                 "Y_region",
#                 "recombination_enhancer",
#                 "silent_mating_type_cassette_array",
#                 "mating_type_region",
#                 "tRNA",
#                 "pseudogenic_transcript",
#                 "ncRNA",
#                 "ncRNA_gene",
#                 "non_transcribed_region",
#                 "rRNA",
#                 "rRNA_gene",
#                 "snRNA",
#                 "snRNA_gene",
#                 "snoRNA",
#                 "snoRNA_gene",
#                 "intein_encoding_region")
### just in case there's some redundancy
vtClassSrt <- unique(vtClassSrt)

## clmnt ----------------------------------------------------------------------

### script name
myName <- current_filename()
cat("[", myName, "] ",
    "Transforming the gff to bed. ",
    "\n", sep = "")

### read strain-haplotypes ids from file
pathIds <- list.files(path = file.path(dirBase, "ids"), pattern = "ids-ps.txt",
                      full.names = T)
vtStrainHaplo <- as.character(fread(file = pathIds, header = F)[[1]])
vtRef <- grep(idRef, vtStrainHaplo, value = T)
### remove the reference
vtStrainHaplo <- grep(idRef, vtStrainHaplo, value = T, invert = T)

### loop for reference annotations
for (indR in vtRef) {
  ### read the gff
  pathAnnoGff <- list.files(path = dirAnnoGff, pattern = indR,
                            full.names = T, recursive = T)
  dtGff <- fread(file = pathAnnoGff, sep = "\t", header = F, verbose = F)
  colnames(dtGff) <- hdGff
  ### id
  strIdPref <- paste0(sub(pattern = "-", replacement = "#", x = indR), "#")
  ### convert the start coordinate from 0-based (gff) to 1-based (bed)
  dtGff[, S_coord := S_coord - 1]
  ### check start and end coordinates: if start = end impg breaks
  nBad <- nrow(dtGff[S_coord >= E_coord])
  if (nBad > 0) {
    cat("[", myName, "] ",
        "Found ", nBad,
        " annotations with the start coordinate larger or equal to",
        " the end coordinate that will be removed.\n",
        sep = "")
    dtGff <- dtGff[S_coord < E_coord]
  }
  ### filter features
  dtGff <- dtGff[Feat_type %in% vtClassSrt, ]
  ### make the feature id column
  strFeatId <- sub("^.*Name=([^;]*).*$", "\\1", dtGff$Attribute_str)
  ### trim after the first ":", e.g. Name=TY3_soloLTR:chrI:183676-184015:-
  strFeatIdTrm <- sub("^([^:]*).*$", "\\1", strFeatId)
  ### trim trailing redundancy, e.g. _intron in YAL003W_intron
  strFeatIdTrm <- sub("^([^_]*).*$", "\\1", strFeatId)
  ### if strFeatId = dtGff[, Feat_type] set strFeatId = "MN"
  indM <- which(dtGff[, Feat_type] == strFeatIdTrm)
  if (length(indM) != 0) {
    strFeatIdTrm[indM] <- "MN"
  }
  ### paste class and feature id (and the strand)
  strName <- paste0(dtGff[, Feat_type], ":",
                    strFeatIdTrm, "#", dtGff[, Strand_id])
  ### transform the gff into a bed file
  dtBed <- data.table(chrom = paste0(strIdPref, dtGff[, Chr_id]),
                      chromStart = dtGff[, S_coord],
                      chromEnd = dtGff[, E_coord],
                      name = strName)
  ### write the bed file
  nameOut <- sub(pattern = "-features.gff$", replacement = ".bed",
                 x = basename(pathAnnoGff))
  pathOutBed <- file.path(dirOut, nameOut)
  fwrite(file = pathOutBed, x = dtBed, sep = "\t",
         quote = F, row.names = F, col.names = F)
}

### dev
### indS <- vtStrainHaplo[1]
### indS <- "AKH_1a-0"
### loop for phenovar annotations
for (indS in vtStrainHaplo) {
  ### read the gff
  pathAnnoGff <- list.files(path = dirAnnoGff, pattern = indS,
                            full.names = T, recursive = T)
  dtGff <- fread(file = pathAnnoGff, sep = "\t", header = F, verbose = F)
  colnames(dtGff) <- hdGff
  ### id
  strIdPref <- paste0(sub(pattern = "-", replacement = "#", x = indS), "#")
  ### convert the start coordinate from 0-based (gff) to 1-based (bed)
  dtGff[, S_coord := S_coord - 1]
  ### check start and end coordinates: if start = end and impg breaks
  nBad <- nrow(dtGff[S_coord >= E_coord])
  if (nBad > 0) {
    cat("[", myName, "] ",
        "Found ", nBad,
        " annotations with the start coordinate larger or equal to",
        " the end coordinate that will be removed.\n",
        sep = "")
    dtGff <- dtGff[S_coord < E_coord]
  }
  ### filter features
  dtGff <- dtGff[Feat_type %in% vtClassSrt, ]
  ### make the feature id column
  strFeatId <- sub("^.*Name=([^;]*).*$", "\\1", dtGff$Attribute_str)
  ### trim after the first ":", e.g. Name=TY3_soloLTR:chrI:183676-184015:-
  strFeatIdTrm <- sub("^([^:]*).*$", "\\1", strFeatId)
  ### trim "tRNA_" from feature id
  strFeatIdTrm <- sub(pattern = "tRNA_", replacement = "", x = strFeatIdTrm)
  ### indexes of the rows that do not contain
  ### nuclear gene names with systematic names, e.g. YAL062W
  indSys <- grep(pattern = "^Y[A-P][L,R][0-9]{3}[W,C]",
                 x = strFeatIdTrm, value = F, invert = T)
  ### if strFeatId = dtGff[, Feat_type] set strFeatId = "MN"
  indM <- which(dtGff[, Feat_type] == strFeatIdTrm)
  if (length(indM) != 0) {
    strFeatIdTrm[indM] <- "MN"
  }
  ### paste class and feature id (and the strand)
  strName <- paste0(dtGff[, Feat_type], ":",
                    strFeatIdTrm, "#", dtGff[, Strand_id])
  ### transform the gff into a bed file
  ### and filter out genes with a systematic name
  dtBed <- data.table(chrom = paste0(strIdPref, dtGff[indSys, Chr_id]),
                      chromStart = dtGff[indSys, S_coord],
                      chromEnd = dtGff[indSys, E_coord],
                      name = strName[indSys])
  ### write the bed file
  nameOut <- sub(pattern = "-features.gff$", replacement = ".bed",
                 x = basename(pathAnnoGff))
  pathOutBed <- file.path(dirOut, nameOut)
  fwrite(file = pathOutBed, x = dtBed, sep = "\t",
         quote = F, row.names = F, col.names = F)
}

```

We invoke impg through a system command to compute the features pangenome. Then we remove the redundancy generated by impg by checking the overlap of the regions computed by impg. To do this, every annotation interval is used to generate a block of homology. Each block of homology is decomposed in sub-blocks which are defined by a feature class. The reduced (i.e. nonredundant) sub-block is then transformed (i.e. formatted) and appended to output.

We write also the generators, i.e. the "class:feature" (e.g. "gene:YGL259W#+") that generated a line in the output "pan-features.txt". A generator may generate multiple lines in "pan-features.txt", e.g. when we analyse genes and pseudogenes a generator may produce a "gene" line and a "pseudogene" line.

```{r computes the pangenome}
## header ---------------------------------------------------------------------

options(scipen = 999)
options(stringsAsFactors = F)
rm(list = ls())
library(data.table)
library(this.path)
library(scriptName)
library(GenomicRanges)
library(tictoc)

## function(s) ----------------------------------------------------------------

#' Split and Extract a Specific Sub-Column from a Character Column
#'
#' This function splits a character column using a specified delimiter 
#' and extracts the desired sub-column based on the given index.
#'
#' @param x A character vector, typically a column from a data table.
#' @param n An integer specifying the index of the sub-column 
#'          to extract after splitting.
#' @param s A character string representing the delimiter used for splitting.
#'
#' @return A character vector containing the extracted sub-column values.
#'
#' @examples
#' # example usage:
#' vec <- c("A|B|C", "D|E|F", "G|H|I")
#' # extract the second sub-column
#' SplitSubCol(vec, 2, "|")  
#'
#' @export
SplitSubCol <- function(x, n, s) {
  y <- sapply(strsplit(x, split = s, fixed = TRUE), "[[", n)
  return(y)
}

## settings -------------------------------------------------------------------

### size threshold: smaller overlaps are removed
sizeLim <- 25
### fixed settings
dirBase <- dirname(this.dir())
### dev dirBase <- "/Users/Lorenzo/dev/panda"
dirAnnoBed <- file.path(dirBase, "anno", "bed")
dirOut <- file.path(dirBase, "png")
unlink(dirOut, recursive = T)
dir.create(dirOut, showWarnings = F)
pathGen <- file.path(dirOut, "generators.txt")
cat("class:feature#strand", "\n", file = pathGen)
idRef <- "SGDref"
hdImpg <- c("Query_id", "Query_start", "Query_end",
            "Target_id", "Target_start", "Target_end",
            "Target_clsfeat", "N_score", "Query_alndir", "Target_alndir")

### the path to the paf file
dirAlnPaf <- file.path(dirBase, "aln")
pathAlnPaf <- list.files(path = dirAlnPaf, pattern = "paf$",
                         recursive = T, full.names = T)
if (length(pathAlnPaf) > 1) {
  cat("[", myName, "] ",
      "User error.\n",
      sep = "")
  ### stop prints "Error: " by default
  stop("multiple paf files found.")
} else if (length(pathAlnPaf) == 0) {
  cat("[", myName, "] ",
      "User error.\n",
      sep = "")
  ### stop prints "Error: " by default
  stop("no paf file found.")
}

## clmnt ----------------------------------------------------------------------

### script name
myName <- current_filename()
cat("[", myName, "] ",
    "Making the pangenome. ",
    "\n", sep = "")

### read strain-haplotypes ids from file (the order is maintained in the output)
pathIds <- file.path(dirBase, "ids", "ids-ps.txt")
vtStrainHaplo <- as.character(fread(file = pathIds, header = F)[[1]])
vtStrainHaploHash <- gsub(pattern = "-", replacement = "#", x = vtStrainHaplo)
### initialise the output features table
nHaplos <- length(vtStrainHaploHash)
dtPanFeats <- data.table(matrix(character(length = 0), ncol = nHaplos))
setnames(dtPanFeats, vtStrainHaploHash)
### dev 
# vtStrainHaploHash <- c("SGDref#0", "AFI#0", "S288C#0",
#                        "XXX-h3", "stoca-zo", "DBVPG6765#0")

## impg run -------------------------------------------------------------------

### message
cat("[", myName, "] ",
    "Running impg. ",
    "\n", sep = "")
### dev indS <- vtStrainHaplo[1] 
indL <- 1
lsImpg <- list()
### for each strain-haplotypes (hyphen-separated)
for (indS in vtStrainHaplo) {
  
  ### pick the strain-haplotypes bed file (query)
  pathAnnoBed <- list.files(path = dirAnnoBed, pattern = indS, full.names = T)
  
  ### run "$ impg -p file.paf -b file.bed"  which is 
  ### (50x faster than going line-by-line)
  ### with direct load of the output
  
  ### string for bash (impg-0.2.0)
  strBashImpg <- paste0("impg -I -p ", pathAlnPaf, " -b ", pathAnnoBed)
  # ### string for bash (impg-0.2.3)
  # strBashImpg <- paste0("impg query -I -p ", pathAlnPaf, " -b ", pathAnnoBed)
  
  strOut <- system(strBashImpg, intern = T)
  ### make a single-file data-table
  lsImpgOne <- strsplit(strOut, split = "\t")
  dtImpgOne <- rbindlist(lapply(lsImpgOne,
                                function(x) as.data.table(as.list(x))))
  ### append the single-file data-table to a list
  lsImpg[[indL]] <- dtImpgOne
  sizeList <- format(object.size(lsImpg), units = "auto")
  cat("[", myName, "] ",
      "Size of impg's list: ", sizeList, " at iteration: ",
      indL, " out of ", length(vtStrainHaplo), ".",
      "\n", sep = "")
  indL <- indL + 1
}
cat("[", myName, "] ",
    "Running impg: done.",
    "\n", sep = "")

### get the redundant data-table
dtImpgAll <- rbindlist(lsImpg)
colnames(dtImpgAll) <- hdImpg
### add supplementary columns
dtImpgAll[, c("Query_start", "Query_end") := lapply(.SD, as.numeric),
          .SDcols = c("Query_start", "Query_end")]
dtImpgAll[, Target_cls := SplitSubCol(Target_clsfeat, 1, ":")]
dtImpgAll[, c("Target_start", "Target_end") := lapply(.SD, as.numeric),
          .SDcols = c("Target_start", "Target_end")]
dtImpgAll[, Target_len := Target_end - Target_start]
dtImpgAll[, Query_len := Query_end - Query_start]

## overlap size filter --------------------------------------------------------

### size filter
dtImpgAllSzFlt <- dtImpgAll[Target_len > sizeLim
                            & Query_len > sizeLim]
cat("[", myName, "] ",
    "Overlap size filter. ",
    "\n", sep = "")
nDtImpgAll <- nrow(dtImpgAll)
nDtImpgAllSzFlt <- nrow(dtImpgAllSzFlt)
nSmall <- nDtImpgAll - nDtImpgAllSzFlt
cat("[", myName, "] ",
    "Removing ", nSmall,
    " entries out of ", nDtImpgAll, ".",
    "\n", sep = "")

### garbage collection
rm(dtImpgAll)
invisible(gc())

## sorting and formatting -----------------------------------------------------

### sorting ascending or descending is not equivalent since the 
### overlap is done in two rounds and 
### is strand-aware (if two features have overlapping 
### coordinates but one is in the + strand and the other is in 
### the - strand they do not overlap), thus
### we sort in increasing (ascending) order to avoid spurious
### overlaps that may occur when multiple classes are analysed
### (a spurious overlap will produce a big block that cannot be easily
### decomposed, except for the different classes);
### the YFL066C locus (where we have the Y' region TEL06L) is a good
### example of a spurious overlap
setorder(dtImpgAllSzFlt, Target_len)

### transfer the strand data from Target_clsfeat to Query_id and Target_id,
### so that when we calculate the blocks these will be strand-aware
strStrand <- SplitSubCol(dtImpgAllSzFlt[, Target_clsfeat], 2, "#")
dtImpgAllSzFlt[, Query_id := paste0(Query_id, "#", strStrand)]
dtImpgAllSzFlt[, Target_id := paste0(Target_id, "#", strStrand)]

## blocks calculation ---------------------------------------------------------

cat("[", myName, "] ",
    "Blocks calculation. ",
    "\n", sep = "")
nBlocks <- 1
vtUnq <- unique(dtImpgAllSzFlt[, Target_clsfeat])
### dev
# indTarClsFeat <- "Y_prime_element:TEL06L#-"
# indTarClsFeat <- "gene:YAR014C#-"
# indTarClsFeat <- "gene:YBL037W#+"
# indTarClsFeat <- "X_element:TEL01L#-"
# indTarClsFeat <- "gene:YBR140C#-"
# indTarClsFeat <- "ARS:ARS102#+"
# indTarClsFeat <- "gene:YCR012W#+"
### quello con molti haplo-id doppioni, indSb <- "TY1/TY2_soloLTR"
# indTarClsFeat <- "TY1:MN#-" 
# indTarClsFeat <- "gene:YGR296W#+"
# which(vtUnq == "gene:YGR296W#+")
# indTarClsFeat <- "gene:S288C_G0022800#+"
# which(vtUnq == "gene:S288C_G0022800#+")
# which(vtUnq == "ARS+ARS102#+")
# which(vtUnq == "X_element+TEL01L#+")
# indTarClsFeat <- unique(dtImpgAllSzFlt[, Target_clsfeat])[3]
# indTarClsFeat <- vtUnq[1]

### YAL005C overlaps with YAL004W, we do not want these two genes
### to generate a single sub-block, so we make the overlap strand-aware
# indTarClsFeat <- "gene:YAL004W#+"
# indTarClsFeat <- "gene:YAL005C#-"
for (indTarClsFeat in vtUnq) {
  
  ### dev print(nBlocks)
  
  ### get the target class-feature that will generate the block
  dtTarClsFeat <- dtImpgAllSzFlt[indTarClsFeat, on = "Target_clsfeat"]
  ### check if the corresponding interval is still in dtImpgAllSzFlt
  ### (if it was ovelapping with a former indTarClsFeat
  ### it has already been removed, but dtTarClsFeat will still have a line
  ### e.g. the following):
  ### Query_id Query_start Query_end Target_id Target_start Target_end
  ###   <char>       <num>     <num>    <char>        <num>      <num>
  ###     <NA>         NA        NA      <NA>           NA         NA
  ### Target_clsfeat N_score Query_alndir Target_alndir Target_cls Target_len
  ###         <char>  <char>       <char>        <char>     <char>      <num>
  ###    buciodeculo    <NA>         <NA>          <NA>       <NA>         NA
  
  if (any(is.na(dtTarClsFeat[, Query_id]))) {
    next
  }
  
  ### first round of overlap (on query coordinates)
  setkey(dtTarClsFeat, Query_id, Query_start, Query_end)
  dtIndOverOne <- foverlaps(dtImpgAllSzFlt, dtTarClsFeat,
                            nomatch = NULL, type = "any", which = T)
  dtBlock <- dtImpgAllSzFlt[dtIndOverOne[, xid], ]
  ### dev print(format(object.size(dtBlock), units = "auto"))
  
  ### second round of overlap (on target coordinates)
  setkey(dtBlock, Target_id, Target_start, Target_end)
  dtIndOverTwo <- foverlaps(dtImpgAllSzFlt, dtBlock, 
                            nomatch = NULL, type = "any", which = T)
  dtBlock <- rbindlist(list(dtBlock, dtImpgAllSzFlt[dtIndOverTwo[, xid], ]))
  ### dev print(format(object.size(dtBlock), units = "auto"))
  
  ### block classes
  allClassesInBlock <- unique(dtBlock[, Target_cls])
  
  ### dev
  # cat(indTarClsFeat, "\t",
  #     nBlocks, "\t", length(allClassesInBlock), "\n",
  #     file = "~/Desktop/check-nsb.txt", append = T)
  
  ## sub-blocks reduction (class-by-class, strand-aware) ----------------------
  
  ### dev
  # indSb <- "gene"
  # indSb <- "TY1/TY2_soloLTR"
  # indSb <- "Y_prime_element"
  for (indSb in allClassesInBlock) {
    ### reduce (same as bedtools merge) the rows for each class
    ### on the basis of the query coordinates
    grSblock <- GRanges(seqnames = dtBlock[Target_cls == indSb, Query_id],
                        ranges = IRanges(start = dtBlock[Target_cls == indSb,
                                                         Query_start],
                                         end = dtBlock[Target_cls == indSb,
                                                       Query_end]),
                        mcols = dtBlock[Target_cls == indSb, Target_clsfeat])
    grSblockRed <- reduce(grSblock)
    
    ### vector with the features names and class name
    ### cleaned of the "#+" or "#-" at the end of the string
    ### e.g. "gene:S288C_G0022800" and "gene:YGR296W" 
    vtClsFeat <- sub(pattern = "#[\\+\\-]$",
                     replacement = "",
                     x = unique(grSblock$mcols))
    ### features string
    strFeats <- paste(gsub(pattern = paste0(indSb, ":"), replacement = "",
                           x = vtClsFeat),
                      collapse = ",")
    
    dtSblockRed <- data.table(as.character(grSblockRed@seqnames),
                              as.character(grSblockRed@ranges))
    
    ## transformation of the reduced sub-block --------------------------------
    
    ### e.g. this dtSblockRed:
    ###                 V1              V2
    ###             <char>          <char>
    ###  SGDref#0#chrVII#+ 1084864-1090591
    ###   S288C#0#chrVII#+ 1085116-1090843
    ###
    ### becomes a two-column data-table with columns:
    ###                 SGDref#0                     S288C#0
    ###                   <char>                      <char>
    ### chrVII:1084864-1090591#+    chrVII:1085116-1090843#+
    
    ### transposition and collapsing explained with
    ### another example, this dtSblockRed:
    ###                      V1            V2
    ###                  <char>        <char>
    ###     DBVPG6765#0#chrIV#- 960288-966619
    ###         AFI#0#chrXIII#- 349539-349680
    ###         AFI#0#chrXIII#- 349713-349989
    ###   DBVPG6765#0#chrXIII#- 354903-355179
    ###           AFI#0#chrIV#- 960661-961002
    ###       S288C#0#chrXIII#- 384508-384784
    ###      SGDref#0#chrXIII#- 378732-379008
    ###
    ### must produce this column:
    ### DBVPG6765#0
    ### chrIV:960288-966619;chrXIII:354903-355179
    
    ### formatting dtSblockRed
    dtSblockRed[, Haplo_id := sub("#chr.*", "", dtSblockRed[, V1])]
    dtSblockRed[, Info_str := paste(SplitSubCol(x = dtSblockRed[, V1],
                                                n = 3, s = "#"),
                                    dtSblockRed[, V2],
                                    sep = ":")]
    ### collapsing with ";" all the Haplo_id elements of a Haplo_id
    dtSblockRedCo <- dtSblockRed[, paste(Info_str, collapse = ";"),
                                 by = Haplo_id]
    ### transpose, producing a data-table
    dtTra <- transpose(dtSblockRedCo)
    ### set column names and format
    setnames(dtTra, as.character(dtTra[1, ]))
    dtTra <- dtTra[-1]
    ### add Class_id and Features_id columns
    dtTra[, ':='(Class_id = rep(indSb, .N), Features_id = rep(strFeats, .N))]
    
    ### add the missing columns: not needed 
    ### since rbindlist makes it by default using fill = TRUE
    # newCols <- setdiff(vtStrainHaploHash, colnames(dtTra))
    # dtTra[, (newCols) := lapply(newCols, function(x) NA)]
    # setcolorder(dtTra, vtStrainHaploHash)
    
    ### append with rbindlist matching (default operation) column names
    dtPanFeats <- rbindlist(list(dtPanFeats, dtTra), fill = T)
    
    ### append the generator feature to the output
    cat(rep(indTarClsFeat, nrow(dtTra)), sep = "\n",
        append = T, file = pathGen)
    ### dev print(nrow(dtTra))
  }
  
  ### delete dtIndOverOne and dtIndOverTwo rows in dtImpgAllSzFlt,
  ### the (any(is.na(dtTarClsFeat[, Query_id]))) will avoid 
  ### the loop to break
  indOut <- unique(c(dtIndOverOne[, xid], dtIndOverTwo[, xid]))
  dtImpgAllSzFlt <- dtImpgAllSzFlt[-indOut]
  
  nBlocks <- nBlocks + 1
  
  ### stop prints "Error: " by default
  ### dev if (nBlocks == 20) stop("we did 20 iterations!")
}
cat("[", myName, "] ",
    "Blocks calculation left ",
    nrow(dtImpgAllSzFlt),
    " impg lines. ",
    "\n", sep = "")

cat("[", myName, "] ",
    "Blocks calculation: done. ",
    "\n", sep = "")

### format and write dtPanFeats
leftCols <- c("Class_id", "Features_id")
colOrder <- c(leftCols, setdiff(names(dtPanFeats), leftCols))
setcolorder(dtPanFeats, colOrder)
pathOutPanFeat <- file.path(dirOut, "pan-features.txt")
write.table(x = dtPanFeats, file = pathOutPanFeat, append = F, quote = F,
            sep = "\t", col.names = T, row.names = F, na = "MA")
save(dtPanFeats, file = file.path(dirOut, "pan-features.RData"))

```

Here, we run the statistics on one type of sub-blocks, the genes. The genomic regions (aka the intervals) are filtered by size. Only those larger than half the median interval size of a sub-block are retained.  

```{r makes the statistics on one type of sub-blocks}

options(scipen = 999)
options(stringsAsFactors = F)
rm(list = ls())
library(data.table)
library(this.path)
library(scriptName)

## function(s) ----------------------------------------------------------------

#' Count Non-NA Values in a Vector
#'
#' This function takes a numeric, character, or logical vector and counts 
#' the number of non-NA (non-missing) values in it.
#'
#' @param x A vector of any type (numeric, character, or logical) 
#'          from which non-NA values will be counted.
#' @return An integer representing the number of non-NA values in `x`.
#' @examples
#' # example usage:
#' CountNoNa(c(1, 2, NA, 4, NA))    # returns 3
#' CountNoNa(c("A", "B", NA, "D"))  # returns 3
#' CountNoNa(c(TRUE, NA, NA, TRUE)) # returns 2
#' @export
CountNoNa <- function(x) {
  z <- sum(!is.na(x))
  return(z)
}

#' Count Semicolon-Separated Sub-strings in a Vector
#'
#' This function counts the total number of sub-strings 
#' in a string vector where 
#' elements are made of sub-strings separated by semicolons (`;`). 
#' It first removes `NA` values, 
#' then splits each remaining string by `;`, 
#' and finally sums up the total 
#' number of separated elements.
#'
#' @param x A character vector where elements may contain 
#'          semicolon-separated values.
#' @return An integer representing the total number of elements after splitting 
#'         non-NA values by semicolons.
#' @examples
#' # example usage:
#' CountSemicSep(c("A;B;C", "D;E", NA, "F")) # returns 6 (3+2+1)
#' CountSemicSep(c(NA, "X;Y;Z", "P;Q", ""))  # returns 5 (3+2+0)
#' CountSemicSep(c(NA, NA))                  # returns 0
#' @export
CountSemicSep <- function(x) {
  z <- sum(lengths(strsplit(x[!is.na(x)], ";")))
  return(z)
}

#' Count Features in a Comma-Separated String
#'
#' This function counts the number of features in a character vector where 
#' values are separated by commas (`,`).
#' If a value does not contain any commas, 
#' it is assumed to be a single feature. 
#' The function correctly handles `NA` values.
#'
#' @param x A character vector where each element may contain 
#'          comma-separated features.
#' @return An integer vector of the same length as `x`, where each value 
#'         represents the number of features 
#'         in the corresponding element of `x`.
#' @examples
#' # example usage:
#' CountAnyFeat(c("A,B,C", "D,E", NA, "F")) # returns c(3, 2, NA, 1)
#' CountAnyFeat(c("X,Y,Z", "P,Q", "R", "")) # returns c(3, 2, 1, 1)
#' CountAnyFeat(c(NA, NA, "A,B"))           # returns c(NA, NA, 2)
#' @export
CountAnyFeat <- function(x) {
  z <- sapply(gregexpr(",", x),
              function(y) ifelse(y[1] == -1, 1L, length(y) + 1L))
  return(z)
}

#' Count Systematic Gene Features in a Character Vector
#'
#' This function counts the number of occurrences of systematic gene features 
#' in a character vector based on a predefined regular expression pattern.
#' The pattern follows the format: `Y[A-P][L,R][0-9]{3}[W,C]`, 
#' which is commonly used for systematic yeast gene names.
#'
#' @param x A character vector where each element 
#'          may contain systematic gene names.
#' @return An integer vector of the same length as `x`, 
#'         where each value represents 
#'         the number of systematic gene matches 
#'         in the corresponding element of `x`.
#' @examples
#' # example usage:
#' CountSysFeat(c("YAL001W,YBR102C", "YDL113C,YGR098W", NA, "YPR202W")) 
#' # returns c(2, 2, NA, 1)
#' 
#' CountSysFeat(c("YAL003W", "YCR008W,YHR209C", "NotAGene", "Blinda")) 
#' # returns c(1, 2, 0, 0)
#' 
#' CountSysFeat(c(NA, NA, "YML075C,YPL197W,YJL112W")) 
#' # returns c(NA, NA, 3)
#' @export
CountSysFeat <- function(x) {
  ### the pattern for systematic yeast gene names
  ptnSys <- "Y[A-P][L,R][0-9]{3}[W,C]"
  
  ### apply the regular expression and count occurrences
  y <- sapply(gregexpr(ptnSys, x, perl = T), function(x) sum(x > 0))
  
  return(y)
}

#' Count Random Identifier Gene Features in a Character Vector
#'
#' This function counts the number of occurrences of genes with a random id 
#' in a character vector based on a predefined regular expression pattern.
#' The pattern follows the format: `"_G[0-9]{7}"`, which identifies gene ids 
#' starting with the stain name, followed by `_G`, 
#' followed by exactly seven digits.
#'
#' @param x A character vector where each element 
#'          may contain random ID gene names.
#' @return An integer vector of the same length as `x`, 
#'         where each value represents 
#'         the number of random ID gene matches 
#'         in the corresponding element of `x`.
#' @examples
#' # example usage:
#' CountRidFeat(c("ABA_G0053280,CMF_HP1_G0054150", "AAB_G7654321"))
#' # returns c(2, 1)
#' 
#' CountRidFeat(c("DBVPG6765_G0027560,YFL051C,YJL216C", "", "NoMatch"))
#' # returns c(1, 0, 0)
#' 
#' CountRidFeat(c(NA, NA, "AAB_G5555555,AIL_G6666666"))
#' # returns c(NA, NA, 2)
#' @export
CountRidFeat <- function(x) {
  ### the pattern for random ID genes
  ptnRid <- "_G[0-9]{7}"
  
  ### apply the regular expression and count occurrences
  y <- sapply(gregexpr(ptnRid, x, perl = T), function(x) sum(x > 0))
  
  return(y)
}

#' Prepend Column Names to Substrings in Selected Columns of a data.table
#'
#' This function modifies a `data.table` by prepending each value 
#' in the specified columns 
#' with the corresponding column name followed by `#`. 
#' Substrings within a column are assumed 
#' to be separated by semicolons (`;`). `NA` values remain unchanged.
#'
#' @param x A `data.table` containing the dataset to be modified.
#' @param y A numeric vector of column indices specifying 
#'          which columns should be modified.
#'
#' @return The input `data.table` is modified in-place, 
#' with the selected columns updated 
#' to have their column names prefixed to each substring.
#'
#' @examples
#' library(data.table)
#' 
#' # create example data.table
#' dt <- data.table(
#'   ID = 1:3,
#'   SGD#0 = c("chrIV:30-32", "chrXIV:386-541;chrXIV:260-415", NA),
#'   AAB#1 = c("", "chrV:35-80", "chrXII:99-111")
#' )
#' 
#' # define columns to modify 
#' # (assuming SGD#0 is in column 2 and AAB#1 in column 3)
#' indHapCols <- c(2, 3)
#'
#' # apply the function
#' AddColPref(dt, indHapCols)
#'
#' # expected output:
#' #     ID   SGD#0                                        AAB#1
#' # 1:  1    SGD#0#chrIV:30-32                            ""  (unchanged)
#' # 2:  2    SGD#0#chrXIV:386-541;SGD#0chrXIV:260-415     AAB#1#chrV:35-80
#' # 3:  3    NA (unchanged)                               AAB#1#chrXII:99-111
#'
#' @export
AddColPref <- function(x, y) {
  x[, (y) := lapply(y, function(indC) {
    col_name <- names(x)[indC]
    ifelse(!is.na(x[[indC]]),
           gsub("([^;]+)", paste0(col_name, "#\\1"), x[[indC]], perl = T),  
           x[[indC]])})]
  return(x)
}

#' Replace NA Values with Empty Strings in a data.table
#'
#' This function modifies a data.table replacing all NA values 
#' with empty strings ("").
#' You can choose whether to apply this only to character 
#' columns or to all columns
#' (which will coerce all types to character).
#'
#' @param x A `data.table` object to modify in-place.
#' @param y Logical. If `TRUE`, replaces NA in all columns 
#'          (and coerces to character).
#'          If `FALSE` (default), replaces only NA values
#'          in character columns.
#'
#' @return The modified `data.table` with NA values replaced by "".
#' @examples
#' library(data.table)
#' x <- data.table(A = c("apple", NA), B = c(NA, "orange"), C = c(1, NA))
#' ReplaceNAtoEmpty(x)         # only character columns
#' ReplaceNAtoEmpty(x, TRUE)   # all columns, coerced to character
ReplaceNAtoEmpty <- function(x, y = F) {
  if (!data.table::is.data.table(x)) {
    ### stop prints "Error: " by default
    stop("input must be a data.table.")
  }
  colsToMod <- if (y) names(x) else names(x)[sapply(x, is.character)]
  
  x[, (colsToMod) := lapply(.SD, function(x) {
    x[is.na(x)] <- ""
    x
  }), .SDcols = colsToMod]
  
  return(x)
}

#' Replace Empty Strings with NA Values in a data.table
#'
#' This function modifies a data.table by replacing all empty strings ("")
#' with NA values. You can choose whether to apply this only to character 
#' columns or to all columns (which will coerce all types to character).
#'
#' @param x A `data.table` object to modify in-place.
#' @param y Logical. If `TRUE`, replaces "" in all columns 
#'          (and coerces to character).
#'          If `FALSE` (default), replaces only "" values
#'          in character columns.
#'
#' @return The modified `data.table` with "" values replaced by NA.
#' @examples
#' library(data.table)
#' x <- data.table(A = c("apple", ""), B = c("", "orange"), C = c("1", ""))
#' ReplaceEmptyToNA(x)         # only character columns
#' ReplaceEmptyToNA(x, TRUE)   # all columns, coerced to character
ReplaceEmptyToNA <- function(x, y = F) {
  if (!data.table::is.data.table(x)) {
    stop("input must be a data.table.")
  }
  colsToMod <- if (y) names(x) else names(x)[sapply(x, is.character)]
  
  x[, (colsToMod) := lapply(.SD, function(col) {
    col[col == ""] <- NA
    col
  }), .SDcols = colsToMod]
  
  return(x)
}

#' Filter intervals in a semicolon-separated genomic string based on a list
#' of valid ("kept") intervals.
#'
#' @param cell A character string of the form "chr:start-end;chr:start-end;..."
#'             or NA.
#' @param regs A character vector of intervals to retain, in the
#'             same "chr:start-end" format.
#'
#' @return A semicolon-separated string of intervals found in both the cell
#'         and the kept list, or NA if none match.
#' @examples
#' dtRegions <- data.table(
#' "Class_id" = c("gene", "gene", "gene", "gene", "gene"),
#' "Features_id" = c("anello", "del", "conte", "antani", "sblinda"),
#' "SGDref#0" = c(
#'   "chrVII:9161-9695",
#'   "chrVII:9518-9751",
#'   NA,
#'   "chrXIV:1375-2528;chrXIV:36539-36694;chrIV_chrII:36539-37694",
#'   "chrX:1000-1010;chrX:1200-1800"),
#' "BUCIO#1" = c(
#'   "chrV:9161-9295",
#'   NA,
#'   NA,
#'   NA,
#'   "chrX:1000-2010;chrX:1200-1800"),
#' "DECULO#2" = c(
#'   "chrV:9161-9895",
#'   NA,
#'   NA,
#'   NA,
#'   NA)
#' )
FilterCellByKeptIntervals <- function(cell, reg) {
  if (is.na(cell)) return(NA_character_)
  allParts <- unlist(strsplit(cell, ";", fixed = T))
  intvKept <- allParts[allParts %in% reg]
  if (length(intvKept) == 0) return(NA_character_)
  paste(intvKept, collapse = ";")
}

## settings -------------------------------------------------------------------

### reference genome
idRefHap <- "SGDref-0"
### pattern of systematic genes
ptnSys <- "Y[A-P][L,R][0-9]{3}[W,C]"
### pattern of random id genes
ptnRid <- "_G[0-9]{7}"
### the type of sub-blocks to process
strSblock <- "gene"

### fixed settings
dirBase <- dirname(this.dir())

### output
dirOut <- file.path(dirBase, "sts", strSblock)
unlink(dirOut, recursive = T)
dir.create(dirOut, recursive = T)
pathPanGenesHaplo <- file.path(dirOut, "sts-by-haplos.txt")
pathNorefPriv <- file.path(dirOut, "n-rid-private.txt")
pathCountSblocsRegs <- file.path(dirOut, "n-sblocks-regs.txt")
pathPanGenesGenomes <- file.path(dirOut, "sts-by-genomes.txt")

## clmnt ----------------------------------------------------------------------

### script name
myName <- current_filename()
cat("[", myName, "] ",
    "Making the statistics. ",
    "\n", sep = "")

### load SGDref features
pathBedRef <- file.path(dirBase, "anno", "bed", paste0(idRefHap, ".bed"))
dtBedRef <- fread(file = pathBedRef, sep = "\t", header = F)
names(dtBedRef) <- c("Strain_hap_chr", "S_coord",
                     "E_coord", "Class_feat_strand")
dtBedRefGns <- dtBedRef[grep("^gene", Class_feat_strand)]

# ### load the generators
# pathInGrt <- file.path(dirBase, "png", "generators.txt")
# dtGrt <- fread(file = pathInGrt,
#                sep = ":", header = T)
# dtGrt[, c("Features_id", "Strand_id") := 
#         tstrsplit(.SD[[which(colnames(dtGrt) == "feature#strand")]], "#")]
# setnames(dtGrt, old = which(colnames(dtGrt) == "class"), new = "Class_id")

### load the pangenome (dtPanFeats)
pathInPan <- file.path(dirBase, "png", "pan-features.RData")
load(pathInPan)
### dev dtPanFeats <- dtPanFeats[1:20, 1:10, with = F]

### we need the first and last haplotype columns to correctly subset 
### the data-table when we calculate the statistics 
nHaplos <- ncol(dtPanFeats) - 2
indHapCols <- 3:ncol(dtPanFeats)

## filter sub-blocks by regions size ------------------------------------------

dtPanFeatsRaw <- dtPanFeats[Class_id == strSblock]

### columns with genomic intervals
intervalCols <- setdiff(names(dtPanFeatsRaw), c("Class_id", "Features_id"))

### process each row independently
dtPanFeatsGns <- dtPanFeatsRaw[, {
  ### extract all intervals in one row across all genomic columns
  allIntervals <- unlist(tstrsplit(unlist(.SD), ";", fixed = T))
  allIntervals <- allIntervals[!is.na(allIntervals)
                               & grepl(":", allIntervals)]
  
  if (length(allIntervals) == 0) {
    ### if there are no valid intervals
    outCols <- lapply(.SD, function(x) NA_character_)
  } else {
    ### calculate interval lengths
    intervalCoords <- tstrsplit(gsub(".*:", "", allIntervals), "-", fixed = T)
    intervalStarts <- as.numeric(intervalCoords[[1]])
    intervalEnds <- as.numeric(intervalCoords[[2]])
    intervalLengths <- intervalEnds - intervalStarts
    
    ### compute median
    M <- median(intervalLengths, na.rm = T)
    
    ### identify good intervals (length ≥ 0.5 * M)
    indBon <- which(intervalLengths >= 0.5 * M)
    bonIntervals <- allIntervals[indBon]
    
    ### rebuild each genomic column
    outCols <- lapply(.SD, FilterCellByKeptIntervals,
                      reg = bonIntervals)
  }
  
  ### return Class_id and Features_id along with filtered columns
  c(list(Class_id = Class_id, Features_id = Features_id), outCols)
}, by = seq(1:nrow(dtPanFeatsRaw)), .SDcols = intervalCols]

### clean up row index
dtPanFeatsGns[, seq := NULL]

### garbage collection
rm(dtPanFeatsRaw)
invisible(gc())

## sub-blocks statistics ------------------------------------------------------

cat("[", myName, "] ",
    "Counting on sub-blocks labelled as: ",
    strSblock,
    "\n", sep = "")
### dev dtPanFeatsGns[20, 4:10] <- NA

nSBlocks <- nrow(dtPanFeatsGns)
cat("[", myName, "] ",
    "Number of sub-blocks: ",
    nSBlocks,
    "\n", sep = "")

nSys <- nrow(dtPanFeatsGns[grep(ptnSys, Features_id)])
cat("[", myName, "] ",
    "Number of sub-blocks with systematic label(s): ",
    nSys,
    "\n", sep = "")

nLabellable <- nrow(dtPanFeatsGns[grepl(ptnSys, Features_id)
                                  & grepl(ptnRid, Features_id)])
cat("[", myName, "] ",
    "Number of sub-blocks with at least one labellable feature: ",
    nLabellable,
    "\n", sep = "")

nUnl <- nrow(dtPanFeatsGns[grep(ptnSys, Features_id, invert = T)])
cat("[", myName, "] ",
    "Number of sub-blocks with only random label(s): ",
    nUnl,
    "\n", sep = "")

## presence (haplotype-based) -------------------------------------------------

### number of haplotypes with at least one region in the sub-block
dtPanFeatsGns[, Ν_pres := rowSums(!is.na(as.matrix(.SD))),
              .SDcols = indHapCols]
### fraction of haplotypes with at least one region in the sub-block
dtPanFeatsGns[, F_pres := c(Ν_pres / nHaplos) ]

## core and dispensable sub-blocks statistics (haplotype-based) ---------------

### all core
cat("[", myName, "] ",
    "Number of core genes (haplotype-based): ",
    dtPanFeatsGns[, sum(F_pres == 1)],
    "\n", sep = "")
### all but one core
cat("[", myName, "] ",
    "Number of N-1 core genes (haplotype-based): ",
    dtPanFeatsGns[, sum(Ν_pres >= c(nHaplos - 1))],
    "\n", sep = "")
### all but two core
cat("[", myName, "] ",
    "Number of N-2 core genes (haplotype-based): ",
    dtPanFeatsGns[, sum(Ν_pres >= c(nHaplos - 2))],
    "\n", sep = "")
### strictly dispensable: 1 ≤ N presence < all
cat("[", myName, "] ",
    "Number of strictly dispensable genes (haplotype-based): ",
    dtPanFeatsGns[, sum(Ν_pres < nHaplos)],
    "\n", sep = "")
### common dispensable: 1 < N presence < all
cat("[", myName, "] ",
    "Number of common dispensable (haplotype-based): ",
    dtPanFeatsGns[, sum(Ν_pres < nHaplos
                        & 1 < Ν_pres)],
    "\n", sep = "")
### 1-leniently common dispensable: 1 < N presence < all - 1
cat("[", myName, "] ",
    "Number of 1-leniently common dispensable (haplotype-based): ",
    dtPanFeatsGns[, sum(Ν_pres < c(nHaplos - 1)
                        & 1 < Ν_pres)],
    "\n", sep = "")
### 2-leniently common dispensable: 1 < N presence < all - 2
cat("[", myName, "] ",
    "Number of 2-leniently common dispensable (haplotype-based): ",
    dtPanFeatsGns[, sum(Ν_pres < c(nHaplos - 2)
                        & 1 < Ν_pres)],
    "\n", sep = "")
### private
cat("[", myName, "] ",
    "Number of private genes (haplotype-based): ",
    dtPanFeatsGns[, sum(Ν_pres == 1)],
    "\n", sep = "")

## decomposition of the features in each sub-block (haplotype-based) ----------

### count how many features are present in a sub-block with gregexpr
### and using integers only (e.g. 1L), although it does not work with empty 
### strings (but this cannot happen in dtPanFeatsGns[, Features_id])
dtPanFeatsGns[, N_feats := CountAnyFeat(Features_id)]
dtPanFeatsGns[, N_feats_sys := CountSysFeat(Features_id)]
dtPanFeatsGns[, N_feats_rid := CountRidFeat(Features_id)]

### save dtPanFeatsGns with counts
fwrite(file = pathPanGenesHaplo, x = dtPanFeatsGns, sep = "\t",
       row.names = F, col.names = T)

### number of non-reference private features per haplotype
tbNorefPriv <- table(dtPanFeatsGns[Ν_pres == 1 & N_feats_rid == 1,
                                   sub("_(?!.*_).*", "",
                                       Features_id,
                                       perl = T)])
### save
write.table(tbNorefPriv, file = pathNorefPriv, quote = F, sep = "\t",
            row.names = F, col.names = c("Haplo_id", "N_priv"))

### check if N_feats[i] = N_feats_sys[i] + N_feats_rid[i]
dtPanFeatsGns[, Good_sum := ifelse(N_feats_sys + N_feats_rid == N_feats, T, F)]
nTrue <- dtPanFeatsGns[, sum(Good_sum)]
if (nTrue != nrow(dtPanFeatsGns)) {
  cat("[", myName, "] ",
      "N_feats[i] != N_feats_sys[i] + N_feats_rid[i]\n", "\n", sep = "")
  cat("[", myName, "] ",
      "Check i = ", paste(dtPanFeatsGns[Good_sum == F, .I], collapse = ", "),
      "\n", sep = "")
  ### stop prints "Error: " by default
  stop("features patterns probably did not work.")
}

## count sub-blocks and regions (haplotype-based) -----------------------------

dtSb <- dtPanFeatsGns[, lapply(.SD, CountNoNa), 
                      .SDcols = indHapCols]
dtRe <- dtPanFeatsGns[, lapply(.SD, CountSemicSep),
                      .SDcols = indHapCols]
dtN <- rbindlist(list(dtSb, dtRe))
dtT <- transpose(dtN)
dtCounts <- data.table(colnames(dtN),
                       dtT)
colnames(dtCounts) <- c("Haplo_id", "N_sblocks", "N_regions")

### save dtT with counts
fwrite(file = pathCountSblocsRegs, x = dtCounts, sep = "\t",
       row.names = F, col.names = T)

cvSbloc <- sd(dtCounts[, N_sblocks]) / mean(dtCounts[, N_sblocks])
cvRegis <- sd(dtCounts[, N_regions]) / mean(dtCounts[, N_regions])

## collapse haplotypes into genomes ------------------------------------------

dtTmp <- dtPanFeatsGns[, .SD, .SDcols = c(1:2, indHapCols)]
AddColPref(dtTmp, indHapCols)
ReplaceNAtoEmpty(dtTmp)
### remove numeric suffix
vtGnmIds <- gsub("#[0-9]+$", "", names(dtTmp)[indHapCols])
### change column names and identify unique indPes
names(dtTmp)[indHapCols] <-  vtGnmIds
vtGnmIdsUniq <- unique(vtGnmIds)

### initialize output with genome columns
dtPanFeatsGnsGnm <- dtTmp[, .(Class_id, Features_id)]

### process each unique prefix
for (indP in vtGnmIdsUniq) {
  vtColMatched <- which(names(dtTmp) == indP)
  
  if (length(vtColMatched) > 1) {
    colsBon <- dtTmp[, ..vtColMatched]
    dtPanFeatsGnsGnm[, (indP) := do.call(paste, c(colsBon, sep = ";"))]
    dtPanFeatsGnsGnm[, (indP) := gsub("^;|;$", "", get(indP))]
  } else if (length(vtColMatched) == 1) {
    dtPanFeatsGnsGnm[, (indP) := dtTmp[[vtColMatched]]]
  }
}
ReplaceEmptyToNA(dtPanFeatsGnsGnm)

### garbage collection
rm(dtTmp)
invisible(gc())

## presence (genome-based) ----------------------------------------------------

nGenomes <- ncol(dtPanFeatsGnsGnm) - 2
indGnmCols <- 3:ncol(dtPanFeatsGnsGnm)

### number of genomes with at least one region in the sub-block
dtPanFeatsGnsGnm[, Ν_pres := rowSums(!is.na(as.matrix(.SD))),
                 .SDcols = indGnmCols]
### fraction of genomes with at least one region in the sub-block
dtPanFeatsGnsGnm[, F_pres := c(Ν_pres / nGenomes) ]

## core and dispensable sub-blocks statistics (genome-based) ------------------

### all core
cat("[", myName, "] ",
    "Number of core genes (genome-based): ",
    dtPanFeatsGnsGnm[, sum(F_pres == 1)],
    "\n", sep = "")
### all but one core
cat("[", myName, "] ",
    "Number of N-1 core genes (genome-based): ",
    dtPanFeatsGnsGnm[, sum(Ν_pres >= c(nGenomes - 1))],
    "\n", sep = "")
### all but two core
cat("[", myName, "] ",
    "Number of N-2 core genes (genome-based): ",
    dtPanFeatsGnsGnm[, sum(Ν_pres >= c(nGenomes - 2))],
    "\n", sep = "")
### strictly dispensable: 1 ≤ N presence < all
cat("[", myName, "] ",
    "Number of strictly dispensable genes (genome-based): ",
    dtPanFeatsGnsGnm[, sum(Ν_pres < nGenomes)],
    "\n", sep = "")
### common dispensable: 1 < N presence < all
cat("[", myName, "] ",
    "Number of common dispensable (genome-based): ",
    dtPanFeatsGnsGnm[, sum(Ν_pres < nGenomes
                           & 1 < Ν_pres)],
    "\n", sep = "")
### 1-leniently common dispensable: 1 < N presence < all - 1
cat("[", myName, "] ",
    "Number of 1-leniently common dispensable (genome-based): ",
    dtPanFeatsGnsGnm[, sum(Ν_pres < c(nGenomes - 1)
                           & 1 < Ν_pres)],
    "\n", sep = "")
### 2-leniently common dispensable: 1 < N presence < all - 2
cat("[", myName, "] ",
    "Number of 2-leniently common dispensable (genome-based): ",
    dtPanFeatsGnsGnm[, sum(Ν_pres < c(nGenomes - 2)
                           & 1 < Ν_pres)],
    "\n", sep = "")
### private
cat("[", myName, "] ",
    "Number of private genes (genome-based): ",
    dtPanFeatsGnsGnm[, sum(Ν_pres == 1)],
    "\n", sep = "")

## decomposition of the features in each sub-block (genome-based) -------------

### count how many features are present in a sub-block with gregexpr
### and using integers only (e.g. 1L), although it does not work with empty 
### strings (but this cannot happen in dtPanFeatsGns[, Features_id])
dtPanFeatsGnsGnm[, N_feats := CountAnyFeat(Features_id)]
dtPanFeatsGnsGnm[, N_feats_sys := CountSysFeat(Features_id)]
dtPanFeatsGnsGnm[, N_feats_rid := CountRidFeat(Features_id)]

### all core systematic: must be equal to all core
cat("[", myName, "] ",
    "Number of core systematic sub-blocks (genome-based): ",
    dtPanFeatsGnsGnm[, sum(F_pres == 1
                           & N_feats_sys != 0)],
    "\n", sep = "")
### strictly dispensable systematic: 1 ≤ N presence < all
cat("[", myName, "] ",
    "Number of strictly dispensable systematic sub-blocks (genome-based): ",
    dtPanFeatsGnsGnm[, sum(Ν_pres < nGenomes
                           & N_feats_sys != 0)],
    "\n", sep = "")

### save dtPanFeatsGnsGnm with counts
fwrite(file = pathPanGenesGenomes, x = dtPanFeatsGnsGnm, sep = "\t",
       row.names = F, col.names = T)

```
